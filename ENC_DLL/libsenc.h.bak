#ifndef LIBSENC_LIBSENC_H_
#define LIBSENC_LIBSENC_H_

#ifndef ALL_
#define ALL_
#endif

#include <stdint.h>

#define			LIBSENC_VERSION              "1.0.1e (2018/12/5 15:00)"
#define			LIBSENC_VERSION_STR          "libsenc version: 1.0.1e (2018/12/5 15:00)"

#define __DATA_PROTECTOR_ON__
#define __ALTER_ON__

#if defined(linux) || defined(__linux__)
#define TRUE 1
#define FALSE 0
#endif

#define VERSION_CURRENT_VERSION            0x00010000
#define MAGIC_DATA						   0x6b636363

//通用错误码 General Error Code
#define			SENC_SUCCESS													0x00000000
#define			SENC_ERROR_DEVICE_NOT_FOUND										0x00000001  /*未发现设备或设备指针为空*/
#define			SENC_ERROR_DEVICE_OPENED										0x00000002	/*设备已开启*/
#define			SENC_ERROR_DEVICE_CLOSED										0x00000003	/*设备已关闭*/
#define			SENC_ERROR_OUT_OF_MEMORY										0x00000004	/*内存不足*/
#define			SENC_ERROR_DATA_OVERFLOW										0x00000005	/*数据溢出*/
#define			SENC_ERROR_PARAMETER_ERROR										0x00000006	/*命令参数错误*/
#define			SENC_ERROR_TRANSFER_LENGTH_NOT_MATCH							0x00000007	/*实际传输数据长度不一致*/
#define			SENC_ERROR_RECEIVED_DATA_HEAD_ERROR								0x00000008	/*返回数据头命令错误*/
#define			SENC_ERROR_CRC_ERROR											0x00000009	/*返回数据CRC错误*/
#define			SENC_ERROR_MAC_ERROR											0x0000000A	/*返回数据MAC错误*/
#define			SENC_ERROR_ENDPOINT_NOT_MATCH									0x0000000B	/*usb端点不一致*/
#define			SENC_ERROR_RECEIVED_CONFIRM_FAIL								0x0000000C	/*返回命令报告错误*/
#define			SENC_ERROR_WRONG_CMD_TYPE										0x0000000D	/*返回命令类型不一致*/
#define			SENC_ERROR_RETURN_ENC_ATTRIBUTES_NOT_MATCH						0x0000000E	/*返回加密参数不一致*/
#define			SENC_ERROR_RECEIVED_SECURE_SIGN_ERROR							0x0000000F	/*返回数据安全标识错误*/
#define			SENC_ERROR_RECEIVED_DATA_NOT_MATCH								0x00000010	/*返回数据不一致*/
#define			SENC_ERROR_PARAMETER_LENGTH_ERROR								0x00000011	/*传递数据大小错误*/
#define			SENC_ERROR_ENCRYPTION_ATTRIBUTES_ERROR							0x00000012	/*加密参数结构体设置错误*/
#define			SENC_ERROR_DEVICE_LIST_NOT_INITIALIZED							0x00000013	/*设备列表未初始化*/
#define			SENC_ERROR_DEVICE_OPEN_FAILED									0x00000014	/*设备开启失败*/
#define			SENC_ERROR_AES_LENGTH_ERROR										0x00000015	/*AES数据长度错误*/


//libusb错误 LibUSB Error Code
#define			SENC_ERROR_USB_IO												0x00000101	/*usb传输错误*/
#define			SENC_ERROR_USB_INVALID_PARAM									0x00000102	/*usb参数错误*/
#define			SENC_ERROR_USB_ACCESS_DENY										0x00000103	/*usb禁止访问*/
#define			SENC_ERROR_USB_NO_DEVICE										0x00000104	/*usb未发现设备*/
#define			SENC_ERROR_USB_NOT_FOUND										0x00000105	/*usb未发现目标设备*/
#define			SENC_ERROR_USB_BUSY												0x00000106	/*usb端口忙*/
#define			SENC_ERROR_USB_TIMEOUT											0x00000107	/*usb超时*/
#define			SENC_ERROR_USB_OVERFLOW											0x00000108	/*usb数据溢出*/
#define			SENC_ERROR_USB_PIPE												0x00000109	/*usb管道错误*/
#define			SENC_ERROR_USB_INTERRUPTED										0x0000010A	/*usb被终止*/
#define			SENC_ERROR_USB_NO_MEMORY										0x0000010B	/*usb内存不足*/
#define			SENC_ERROR_USB_NOT_SUPPORTED									0x0000010C	/*usb不支持*/
#define			SENC_ERROR_USB_UNKNOWN											0x000001FF	/*usb未知错误*/


#define			SENC_ERROR_PKCS1_V1_5_ENCODE									0x00000201	/*PKCS编码失败*/
#define			SENC_ERROR_PKCS1_V1_5_DECODE									0x00000202	/*PKCS解码失败*/
#define			SENC_ERROR_RSA_VERIFY_FAILED_LENGTH								0x00000203	/*RSA验签失败长度错误*/
#define			SENC_ERROR_RSA_VERIFY_FAILED_DATA								0x00000204	/*RSA验签失败数据错误*/



//板卡错误 Error Code Generated by SencCard
#define			SENC_ERROR_ECSTATE_USB_DEVICE_BUSY								0x10000001	/*板卡设备忙*/
#define			SENC_ERROR_ECSTATE_USB_DATA_SENDING_FAIL						0x10000002	/*板卡usb发送失败*/
#define			SENC_ERROR_ECSTATE_PROTOCOL_HEAD_ERROR							0x10000003	/*板卡协议数据头错误*/
#define			SENC_ERROR_ECSTATE_PROTOCOL_LENGTH_ERROR						0x10000004	/*板卡协议数据长度错误*/
#define			SENC_ERROR_ECSTATE_PROTOCOL_CMD_TYPE_ERROR						0x10000005	/*板卡协议命令类型错误*/
#define			SENC_ERROR_ECSTATE_PROTOCOL_MAC_ERROR							0x10000006	/*板卡协议MAC错误*/
#define			SENC_ERROR_ECSTATE_PROTOCOL_OP_TYPE_ERROR						0x10000007	/*板卡协议操作类型错误*/
#define			SENC_ERROR_ECSTATE_PROTOCOL_SECURE_SIGN_ERROR					0x10000008	/*板卡协议安全标识错误*/
#define			SENC_ERROR_ECSTATE_CARD_STATE_ERROR								0x10000009	/*板卡状态错误*/
#define			SENC_ERROR_ECSTATE_WRITE_ERROR									0x1000000A	/*板卡写错误*/
#define			SENC_ERROR_ECSTATE_READ_ERROR									0x1000000B	/*板卡读错误*/
#define			SENC_ERROR_ECSTATE_SESSION_KEY_ERROR							0x1000000C	/*会话秘钥错误*/
#define			SENC_ERROR_ECSTATE_PROTOCOL_ATTRIBUTE_ERROR						0x1000000D	/*板卡协议数据参数错误*/
#define			SENC_ERROR_ECSTATE_INIT_STATUS_ERROR							0x1000000E	/*板卡初始化状态错误*/
#define			SENC_ERROR_ECSTATE_ALGORITHM_RANDOM_NUM_ERROR					0x10001001	/*板卡算法随机数错误*/
#define			SENC_ERROR_ECSTATE_ALGORITHM_AES_ERROR							0x10001002	/*板卡AES算法错误*/
#define			SENC_ERROR_ECSTATE_ALGORITHM_RSA_ERROR							0x10001003	/*板卡RSA算法错误*/
#define			SENC_ERROR_ECSTATE_ALGORITHM_DES_ERROR							0x10001004	/*板卡DES算法错误*/
#define			SENC_ERROR_ECSTATE_ALGORITHM_SM2_ERROR							0x10001005	/*板卡SM2算法错误*/
#define			SENC_ERROR_ECSTATE_ALGORITHM_SM3_ERROR							0x10001006	/*板卡SM3算法错误*/
#define			SENC_ERROR_ECSTATE_ALGORITHM_SM4_ERROR							0x10001007	/*板卡SM4算法错误*/
#define			SENC_ERROR_ECSTATE_IC_CARD_NOT_EXIST							0x10002001	/*板卡IC卡不存在*/
#define			SENC_ERROR_ECSTATE_IC_CARD_VERIFIED								0x10002002	/*板卡IC卡已验证*/
#define			SENC_ERROR_ECSTATE_MASTER_CARD_NOT_ADDED						0x10003001	/*板卡管理卡未添加*/
#define			SENC_ERROR_ECSTATE_MASTER_CARD_FULL								0x10003002	/*板卡管理卡满*/
#define			SENC_ERROR_ECSTATE_MASTER_CARD_NOT_EXIST						0x10003003	/*板卡管理卡不存在*/
#define			SENC_ERROR_ECSTATE_MASTER_CARD_VERIFY_FAILED					0x10003004	/*板卡管理卡认证失败*/
#define			SENC_ERROR_ECSTATE_MASTER_CARD_VERIFIED							0x10003005	/*板卡管理卡已认证*/
#define			SENC_ERROR_ECSTATE_MASTER_CARD_ADDED							0x10003006	/*板卡管理卡已添加*/
#define			SENC_ERROR_ECSTATE_DONGLE_EXISTED								0x10004001	/*板卡锁已存在*/
#define			SENC_ERROR_ECSTATE_DONGLE_NOT_EXIST								0x10004002	/*板卡锁不存在*/
#define			SENC_ERROR_ECSTATE_DONGLE_ID_ERROR								0x10004003	/*板卡锁ID错误*/
#define			SENC_ERROR_ECSTATE_DONGLE_VERIFY_FAILED							0x10004004	/*板卡锁认证错误*/
#define			SENC_ERROR_ECSTATE_DONGLE_FULL									0x10004005	/*板卡锁已满3个*/
#define			SENC_ERROR_ECSTATE_KEY_INDEX_ERROR								0x10005001	/*板卡密钥索引错误*/
#define			SENC_ERROR_ECSTATE_KEY_ALG_TYPE_ERROR							0x10005002	/*板卡密钥算法类型错误*/
#define			SENC_ERROR_ECSTATE_KEY_NOT_EXIST								0x10005003	/*板卡密钥不存在*/
#define			SENC_ERROR_ECSTATE_KEY_EXISTED									0x10005004	/*板卡密钥已存在*/
#define			SENC_ERROR_ECSTATE_KEY_STORAGE_FULL								0x10005005	/*板卡密钥满*/
#define			SENC_ERROR_ECSTATE_KEY_RSA_READ									0x10005006	/*读取RSA密钥失败*/
#define			SENC_ERROR_ECSTATE_KEY_RSA_DER									0x10005007	/*RSA密钥der编解码失败*/
#define			SENC_ERROR_ECSTATE_KEY_RSA_PUBMOD								0x10005008	/*RSA公钥模运算失败*/
#define			SENC_ERROR_ECSTATE_KEY_RSA_SHA_TYPE								0x10005009	/*RSA验签-哈希类型不支持*/
#define 		SENC_ERROR_ECSTATE_KEY_RSA_MOV_PADING							0x1000500a	/*RSA签名去除填充失败*/
#define			SENC_ERROR_ECSTATE_KEY_RSA_SHA_DATA								0x1000500b	/*RSA验签-哈希数据不正确*/																							 
#define			SENC_ERROR_ECSTATE_CERT_LEN_ERROR								0x10006001	/*证书长度错误*/
#define			SENC_ERROR_ECSTATE_CERT_NOT_EXIT								0x10006002	/*证书不存在*/
#define			SENC_ERROR_ECSTATE_CERT_VERIFY_SIGN_ERROR						0x10006003	/*证书验签名错误*/
#define			SENC_ERROR_ECSTATE_CERT_VERIFY_CERT_ERROR						0x10006004	/*证书验证书错误*/
#define			SENC_ERROR_ECSTATE_CERT_EXISTED									0x10006005	/*证书已存在*/
#define			SENC_ERROR_ECSTATE_CERT_TYPE_ERROR								0x10006006  /*证书类型错误*/
#define			SENC_ERROR_ECSTATE_CERT_GET_PUBKEY_FAILED						0x10006007	/*证书提取公钥失败*/
#define			SENC_ERROR_ECSTATE_CERT_FORMAT_ERROR							0x10006008	/*证书格式错误，解析失败*/
#define			SENC_ERROR_ECSTATE_CERT_COMMEN_BUFFER_TOO_SMALL					0x10006009	/*证书提取公钥，缓存太小*/
#define			SENC_ERROR_ECSTATE_MALLOC_FAILED								0x10008001	/*malloc申请空间失败*/
#define			SENC_ERROR_ECSTATE_GET_RANDOM_FAILED							0x10008002	/*获取随机数失败*/
#define			SENC_ERROR_ECSTATE_GET_CSR_FAILED								0x10008003	/*获取CSR失败*/
#define			SENC_ERROR_ECSTATE_RSA_SM2_VERIFY_FAILED						0x10008004	/*验签失败*/
#define 		SENC_ERROR_ECSTATE_KEY_SM2_GEN_FAILED							0x10009001	/*sm2密钥生成失败*/
#define 		SENC_ERROR_ECSTATE_KEY_SM2_DEC_FAILED							0x10009002	/*sm2解密失败*/
#define 		SENC_ERROR_ECSTATE_KEY_SM2_CSR_REQ_FAILED						0x10009003	/*sm2 构建CSR请求信息失败*/
#define			SENC_ERROR_ECSTATE_KEY_SM2_CSR_CREATE_FAILED					0x10009004	/*sm2 构建CSR失败*/
#define			SENC_ERROR_ECSTATE_KEY_SM2_DER_SIGN_FAILED						0x10009005	/*sm2解码签名失败*/
#define			SENC_ERROR_ECSTATE_KEY_SM2_SIGN_FAILED							0x10009006	/*sm2签名失败*/
#define			SENC_ERROR_ECSTATE_KEY_SM2_VERIFY_FAILED						0x10009007	/*sm2验签失败*/
#define			SENC_ERROR_ECSTATE_KEY_SM2_GET_DEC_FAILED						0x10009008  /*sm2读取并解密密钥失败*/
#define			SENC_ERROR_ECSTATE_KEY_SM2_PUB_DER_FAILED						0x10009009	/*sm2公钥der解码失败*/
#define			SENC_ERROR_ECSTATE_DER_BUFFER_TOO_SMALL							0x1000900a	/*der编解码缓存太小*/
#define			SENC_ERROR_ECSTATE_KEY_SM2_PRI_DER_FAILED						0x1000900b	/*sm2私钥der解码失败*/	
#define			SENC_ERROR_ECSTATE_DER_DEC_CIPHER_FAILED						0x1000900c	/*sm2 der解码密文失败*/
#define			SENC_ERROR_ECSTATE_DER_DEC_SIGN_FAILED							0x1000900d	/*sm2 der解码签名失败*/																							
#define 		SENC_ERROR_ECSTATE_SM4_ECB_ENC_FAILED							0x10009011	/*sm4ECB加密失败*/
#define 		SENC_ERROR_ECSTATE_SM4_ECB_DEC_FAILED							0x10009012	/*sm4ECB解密失败*/
#define 		SENC_ERROR_ECSTATE_SM4_CBC_ENC_FAILED							0x10009013	/*sm4CBC加密失败*/
#define 		SENC_ERROR_ECSTATE_SM4_CBC_DEC_FAILED							0x10009014	/*sm4CBC解密失败*/
#define 		SENC_ERROR_ECSTATE_SM4_BUF_LEN_ERROR							0x10009015	/*sm4加解密buf长度错误，要求是16的整数倍*/																						 
#define			SENC_ERROR_ECSTATE_ENCRYPTOR_KEY_NOT_EXIT						0x1000a001	/*加密机密钥不存在*/
#define			SENC_ERROR_ECSTATE_ENCRYPTOR_KEY_LEN_ERROR						0x1000a002  /*加密机密钥长度错误*/
#define			SENC_ERROR_ECSTATE_BINDCODE_CHECK_FAILED						0x1000a003	/*绑定码检查失败*/
#define			SENC_ERROR_ECSTATE_KEYBAG_PUBKEY_CNT_ERROR						0x1000a004	/*keybag同步公钥数量太多*/
#define			SENC_ERROR_ECSTATE_KEYBAG_NO_PUBKEY								0x1000a005	/*keybag未找到同步公钥*/
#define			SENC_ERROR_ECSTATE_PHONENUM_CHECK_ERROR							0x1000a006	/*电话号码检查错误*/
#define			SENC_ERROR_ECSTATE_TIMESTAMP_CHECK_ERROR						0x1000a007	/*时间戳检查错误*/
#define			SENC_ERROR_ECSTATE_HASH_INDEX									0x1000F001  /*Hash类型不支持*/																					
#define			SENC_ERROR_ECSTATE_USERAPI_VERSION_ERROR						0x1000F301	/*版本错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_KEYFLAG_ERROR						0x1000F302	/*密钥算法，种类错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_MAC_ERROR							0x1000F303	/*MAC错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_ID_ERROR								0x1000F304	/*ID错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_HASH_ERROR							0x1000F305	/*Hash错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_SIGN_ERROR							0x1000F306	/*签名错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_TIME_ERROR							0x1000F307	/*时间错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_LIMITED_TIMES_ERROR					0x1000F308	/*许可条款可用次数错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_LIMITED_POLICY_ERROR					0x1000F309	/*许可条款策略错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_GET_RTC_ERROR						0x1000F30A	/*获取RTC时间错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_PARAMETER_ERROR						0x1000F30B	/*参数错误*/
#define			SENC_ERROR_ECSTATE_USERAPI_KEYFBITS_CHECK_ERROR					0x1000F30C	/*密钥bit长度错误*/


//锁错误 Error Code Generated by Elite4 Dongle
#define			SENC_ERROR_DONGLE_NO_POWER										0x20000001	/*锁未上电*/
#define			SENC_ERROR_DONGLE_INVALID_PARAMETER								0x20000002	/*锁参数无效*/
#define			SENC_ERROR_DONGLE_COMM_ERROR									0x20000003	/*锁通信错误*/
#define			SENC_ERROR_DONGLE_PROTOCOL_ERROR								0x20000004	/*锁数据协议错误*/
#define			SENC_ERROR_DONGLE_DEVICE_BUSY									0x20000005	/*锁设备忙*/
#define			SENC_ERROR_DONGLE_KEY_REMOVED									0x20000006	/*锁被拔除*/
#define			SENC_ERROR_DONGLE_TOO_MANY_DONGLES								0x2000000A	/*锁过多*/
#define			SENC_ERROR_DONGLE_NO_DONGLE										0x2000000B	/*未发现锁*/
#define			SENC_ERROR_DONGLE_INSUFFICIENT_BUFFER							0x20000011	/*buff过小*/
#define			SENC_ERROR_DONGLE_NO_LIST										0x20000012	/*未发现设备列表*/
#define			SENC_ERROR_DONGLE_GENERAL_ERROR									0x20000013	/*锁通用错误*/
#define			SENC_ERROR_DONGLE_UNSUPPORTED									0x20000014	/*锁不支持*/
#define			SENC_ERROR_DONGLE_RSAVERIFY_FAILED								0x20006A80	/*锁RSA认证失败*/
#define			SENC_ERROR_DONGLE_BOUND_FILE_EXISTED							0x20006985	/*锁已存在绑定数据*/

#define			SENC_ERROR_SERIAL_PORT_CANNOT_OPEN								0x21000001	/*串口无法打开*/
#define			SENC_ERROR_SERIAL_PORT_CANNOT_SET_ATTRIBUTE						0x21000002	/*串口无法获取属性*/
#define			SENC_ERROR_SERIAL_PORT_WRITE_ERROR								0x21000003	/*串口写错误*/
#define			SENC_ERROR_SERIAL_PORT_READ_ERROR								0x21000004	/*串口读错误*/
#define			SENC_ERROR_SERIAL_PORT_HANDLE_CLOSED							0x21000005	/*句柄已关闭无法获得设备信息*/
#define			SENC_ERROR_SERIAL_PORT_NO_SERIAL_FOUND							0x21000006	/*未发现串口*/
#define			SENC_ERROR_SERIAL_PORT_RESET_FAILED								0x210000FF	/*复位失败*/

#define			SENC_ERROR_OPENSSL_BN_NEW										0x55100001
#define			SENC_ERROR_OPENSSL_BN_EXPAND									0x55100002
#define			SENC_ERROR_OPENSSL_RSA_NEW										0x55100003
#define			SENC_ERROR_OPENSSL_RSA_PUBLIC_DECRYPT							0x55100004
#define			SENC_ERROR_OPENSSL_RSA_PUBLIC_ENCRYPT							0x55100005
#define			SENC_ERROR_D2I_RSA_PUBLICKEY									0x55100006
#define			SENC_ERROR_OPENSSL_RSA_VERIFY									0x55100007


//未知错误 Unknown Error
#define			SENC_ERROR_UNKNOWN												0xFFFFFFFF


//加密板卡状态 SencCard State Table
#define			SENC_DEVICE_STATE_PRODUCT										0x00	/*生产*/
#define			SENC_DEVICE_STATE_DEFAULT										0x01	/*出厂*/
#define			SENC_DEVICE_STATE_STANDBY										0x02	/*空闲*/
#define			SENC_DEVICE_STATE_OPERATING										0x03	/*操作*/
#define			SENC_DEVICE_STATE_MANAGEMENT									0x04	/*管理*/

//加密板卡初始化状态 SencCard InitStatus Table
#define			SENC_DEVICE_STATUS_BLANK										0x00	/*空白*/
#define			SENC_DEVICE_STATUS_ALREADY										0x01	/*就绪*/

//证书类型
#define			SENC_CERT_ROOT													0x01	/*Root证书*/
#define			SENC_CERT_CA													0x02	/*CA证书*/
#define			SENC_CERT_DEVICE												0x03	/*设备证书*/

//设备指针类型 SencCard Device Handle
typedef			void*			SENCHANDLE;


#define IN   //进入板卡
#define OUT  //从板卡输出


//秘钥参数容器结构体 Attributes of Encryption Methods
typedef struct tagEncryptAttr{
	unsigned char	RSA_Mode;				//RSA加密类型 0x01 2048
	unsigned char	RSA_PrikeyEncMode;		//RSA私钥加密类型 0x01 aes128ecb || 0x02 aes256ecb ||0x03 sm4
	unsigned char	RSA_PrikeyEncIdx;		//私钥加密用对称秘钥索引	1-64
	unsigned char	RSA_InternalKeyIdx;		//RSA内部秘钥索引 1-128
	unsigned char	RSA_HashAlgorithm;		//哈希算法 0x01 sha1 || 0x02 sha256
	unsigned char	RSA_PaddingMode;		//填充方式 0x01 NO_PADDING || 0x02 PKCS1 v1.5
	unsigned char	AES_EncLength;			//AES加密类型 0x01 aes128 || 0x02 aes256
	unsigned char	AES_EncMode;			//AES加密模式 0x01 ecb || 0x02 cbc
	unsigned char	AES_EncIdx;				//AES秘钥索引 65-128
} EncryptAttr;


//设备信息 Device Info by Ports
//每个数组元素为一层的端口号，从后向前，-1为结束
typedef struct tagCardInfo{

	int						Dev_Path[16];	//设备地址
	int						Port_Num;
	int						Case_Num;
	char					Dev_Path_str[16];

} CardInfo;


//板卡设备列表 Device List
typedef struct tagSENCryptCardList{

	int	DevNums;		//设备数量
	CardInfo*		devs[64];			   //板卡列表
	void*			ctx;				   //libusb操作容器指针
	int				InitFlag;			   //列表初始化标识

} SENCryptCardList;


/************************************		数据许可模块 相关		****************************************/
/************************************		数据许可模块 相关		****************************************/
//密钥算法类型、种类
#define ALGID_AES			0x00000001         // AES密钥
#define ALGID_SM4			0x00000002		   // SM4密钥
#define ALGID_RSA_PUB		0x00010100         // RSA公钥
#define ALGID_RSA_PRI		0x00020100         // RSA私钥
#define ALGID_SM2_PUB		0x00010200         // SM2公钥
#define ALGID_SM2_PRI		0x00020200         // SM2私钥

//有效标志（Flag）定义
#define FLAG_START_TIME		0x00000001		   //有效开始时间
#define FLAG_END_TIME		0x00000002		   //有效结束时间
#define FLAG_SPAN_TIME		0x00000004		   //有效时间段
#define FLAG_TIMES			0x00000008		   //有效次数

//策略（Policy）定义
#define POLICY_INHERIT      0x00000001         // 允许继承
#define POLICY_DECRYPT	    0x00000002         // 允许解密
#define POLICY_ENCRYPT	    0x00000004         // 允许加密
#define POLICY_PRINT        0x00001000         // 允许打印
#define POLICY_EXPORT       0x00002000         // 允许导出明文
#define POLICY_UNREVOKABLE  0x00004000         // 不可撤销的

#define	CHIPID_LENGTH		16				   //板卡ID长度
#define	KEYBAGID_LENGTH		8				   //KeyBag ID长度
#define	BINDCODE_PLAIN_LEN	16				   //绑定码明文长度
#define	PHONE_NUMBER_LEN	16				   //手机号码长度
#define	CIRCLE_ID_LEN		16				   //Circle ID长度

//秘钥记录请求
typedef struct tagKeyRecordRequest{
	uint32_t Version;					// 版本号
	uint32_t Reserved;					// 保留字，用于结构体对齐
	uint8_t KeyID[16];					// 密钥ID
	uint8_t OwnerUserID[16];			// 密钥所有者ID
	uint8_t OwnerKeyFingerprint[32];	// 密钥所有者的公钥的指纹
	uint8_t DevlpID[8];					// APP开发商ID
	uint8_t AppID[8];					// APP ID
	int64_t timeStamp;					// 密钥请求生成的时间，5分钟之后失效
	uint32_t Flag;						// 密钥类型，算法
	uint32_t bits;						// 密钥bit长度
	int64_t stTime;						// 密钥有效开始时间
	int64_t endTime;					// 密钥有效结束时间
	uint8_t Signature[256];				// 用户签名，SS端生成，硬件验证
} KeyRecordRequest;

//秘钥记录
typedef struct tagKeyRecord{
	uint32_t Version;					// 版本号
	uint32_t Reserved;					// 保留字，用于结构体手动对齐
	uint8_t KeyID[16];					// 密钥ID
	uint8_t OwnerUserID[16];			// 密钥所有者ID
	uint8_t OwnerKeyFingerprint[32];	// 密钥所有者的公钥的指纹
	uint8_t DevlpID[8];					// APP开发商ID
	uint8_t AppID[8];					// APP ID
	int64_t stTime;						// 密钥有效开始时间
	int64_t endTime;					// 密钥有效结束时间
	uint32_t Flag;						// 密钥类型，算法
	uint32_t bits;						// 密钥bit长度
	uint8_t Key_C_enc[40];				// 卡内部密钥加密的云端密钥
	uint8_t Mac[32];					// 密钥记录的校验码，由硬件计算，硬件验证
}KeyRecord;

//用户公钥信息
typedef struct tagUserPubKey{
	uint32_t Version;					// 版本号
	uint8_t OwnerUserID[16];			// 密钥所有者ID
	uint32_t Reserved;					// 保留字，用于结构体对齐
	int64_t timeStamp;					// 密钥生成时间
	uint32_t Flag;						// 密钥类型，算法
	uint32_t bits;						// 密钥bit长度
	uint32_t KeyLen;					// keyValue中的有效密钥长度
	uint8_t KeyValue[300];				// 用户公钥
	uint8_t Mac[32];					// 用户公钥的校验码，由硬件计算，硬件验证
}UserPubKey;

//许可条款
typedef struct tagLicenseLimited{
	uint32_t Version;					// 版本号
	uint32_t Flag;						// 标志位，标识后续条款的有效性
	int64_t stTime;						// 起始时间
	int64_t endTime;					// 结束时间
	int64_t fsTime;						// 第一次使用时间
	int64_t spanTime;					// 可用时间段
	int64_t times;						// 可用次数
	uint32_t Policy;					// 策略，标识读，写，打印，继承，导出
	uint32_t Reserved;					// 保留字，用于结构体对齐
}LicenseLimited;

//许可信息
typedef struct tagLicense{
	uint32_t Version;					// 版本号
	uint8_t LicID[16];					// 许可ID
	uint8_t FatherLicID[16];			// 父许可ID
	uint8_t IssuerUserID[16];			// 许可签发者ID
	uint8_t OwnerUserID[16];			// 许可所有者ID
	uint8_t OwnerKeyFingerprint[32];	// 许可所有者的公钥的指纹
	uint8_t KeyID[16];					// 被授权的密钥ID
	uint32_t Reserved;					// 保留字，用于结构体手动对齐
	LicenseLimited licLimited;			// 许可条款
	uint8_t Mac[32];					// 许可信息校验码，由硬件计算，硬件验证
}License;

//许可请求
typedef struct tagLicenseRequest{
	uint32_t Version;					// 版本号
	uint8_t FatherLicID[16];			// 父许可ID
	uint8_t OwnerUserID[16];			// 许可所有者ID
	uint8_t OwnerKeyFingerprint[32];	// 许可所有者的公钥的指纹
	uint8_t KeyID[16];					// 被授权的密钥ID
	uint32_t Reserved;					// 保留字，用于结构体手动对齐
	int64_t timeStamp;					// 许可请求生成的时间生成时间，5分钟之后失效
	LicenseLimited licLimited;			// 许可条款
	uint8_t Signature[256];				// 用户签名，SS端生成，硬件验证
}LicenseRequest;

//密文数据包
typedef struct tagS1Cipher{
	uint32_t Version;					// 版本号
	uint32_t Len;						// 密文长度
	uint8_t Cipher[256];				// 密文内容
}S1Cipher;

//秘钥记录有效期
typedef struct tagKeyPeriod{
	uint32_t Version;					// 版本号
	uint8_t	KeyID[16];					// 密钥ID
	uint32_t Reserved;					// 保留字，用于结构体手动对齐
	int64_t timeStamp;					// 有效期数据生成时间，5分钟之后失效
	int64_t stTime;						// 起始时间
	int64_t endTime;					// 结束时间
	uint8_t Signature[256];				// 用户签名，SS端生成，硬件验证
}KeyPeriod;


//板卡初始化请求包
typedef struct tagChipInitRequest{
	uint32_t Version;					//版本号
	uint8_t chipId[CHIPID_LENGTH];      //板卡ID
	uint32_t Flag;						//用于签名的密钥类型、算法
	uint32_t bits;						//用于签名的密钥bit长度
	uint8_t Signaute[256];				//使用板卡的设备私钥对以上数据的签名（SHA256withRSA算法）
}ChipInitRequest;

//板卡初始化命令包Inner
typedef struct tagChipInitCommandInner{
	uint8_t chipId[CHIPID_LENGTH];      //板卡ID
	uint8_t Kseed[32];					//用于生成Kenc和Kmac的种子码
	uint8_t CryptorPri[64];				//加密机私钥（SM2）
	uint32_t Flag;						//用于签名的密钥类型、算法
	uint32_t bits;						//用于签名的密钥bit长度
	uint8_t Signaute[256];				//使管理员锁的设备私钥对以上数据的签名（SHA256withRSA算法）
}ChipInitCommandInner;

//板卡初始化命令包
typedef struct tagChipInitCommand{
	uint32_t Version;					//版本号
	uint32_t Flag;						//用于加密会话密钥的密钥类型、算法
	uint32_t bits;						//用于加密会话密钥的密钥bit长度
	uint32_t sessionKeyFlag;			//会话密钥类型、算法
	uint32_t sessionKeyBits;			//会话密钥bit长度
	uint8_t sessionKeyCipher[256];      //会话密钥密文，使用板卡的设备证书加密，此处会话密钥的明文为[IV+KEY],其中IV长度固定16字节,KEY长度为（sessionKeyBits/8）,下面是加密CHIP_INIT_CMD_INNER的算法为AES256_CBC
	uint32_t cmdCipherLen;				// CHIP_INIT_CMD_INNER的密文长度
	uint8_t cmdCipher[512];				//CHIP_INIT_CMD_INNER的密文，使用会话密钥加密
}ChipInitCommand;

//板卡认证管理员锁数据包Inner
typedef struct tagAuthAdminKeyInner{
	uint8_t rand[32];					//随机数
	uint8_t  Mac[32];					//使用Kmac密钥对以上字段计算的MAC值
}AuthAdminKeyInner;

//板卡认证管理员锁数据包
typedef struct tagAuthAdminKey{
	uint32_t Version;					//版本号
	uint32_t Flag;						// 密钥类型，算法
	uint32_t bits;						// 密钥bit长度
	uint32_t cipherLen;					//密文长度
	uint8_t cipher[128];				//使用Kenc对AUTH_ADM_KEY_INNER加密得到的密文（AES256_ECB算法）
}AuthAdminKey;

//管理员锁复制数据包Inner
typedef struct tagAdminKeyCopyCommandInner{
	uint8_t Kseed[32];					//用于生成Kenc和Kmac的种子码
	uint32_t Flag;						//用于签名的密钥类型、算法
	uint32_t bits;						//用于签名的密钥bit长度
	uint8_t Signaute[256];				//使就绪管理员锁的设备私钥对以上数据的签名（SHA256withRSA算法）
}AdminKeyCopyCommandInner;

//管理员锁复制数据包
typedef struct tagAdminKeyCopyCommand{
	uint32_t Version;					//版本号
	uint32_t Flag;						//用于加密会话密钥的密钥类型、算法
	uint32_t bits;						//用于加密会话密钥的密钥bit长度
	uint32_t sessionKeyFlag;			//会话密钥类型、算法
	uint32_t sessionKeyBits;			//会话密钥bit长度
	uint8_t sessionKeyCipher[256];      //会话密钥密文，使用板卡的设备证书加密，此处会话密钥的明文为[IV+KEY],其中IV长度固定16字节,KEY长度为（sessionKeyBits/8）,下面是加密ADMIN_KEY_COPY_CMD_INNER的算法为AES256_CBC
	uint32_t cmdCipherLen;				//ADMIN_KEY_COPY_CMD_INNER的密文长度
	uint8_t cmdCipher[512];				//ADMIN_KEY_COPY_CMD_INNER的密文，使用会话密钥加密
}AdminKeyCopyCommand;

/************************************		秘钥管理-国密 相关		****************************************/
/************************************		秘钥管理-国密 相关		****************************************/
//KeyChain创建请求包
typedef struct tagKeychainCreateReq
{
	uint32_t u32Magic;					// 魔数，值为0x6b636363，后续数据结构与此相同
	uint32_t u32Version;				// 版本号，值为0x10000，后续数据结构与此相同
	uint32_t u32Flags;
	uint32_t u32TimeStamp;				//时间戳，单位秒
	uint8_t  au8ID[16];					//KeyChain的ID
	uint8_t au8KeyBagID[8];				//KeyBagID
	uint8_t  au8AccessCodePubKey[64];   //SM2公钥，前32个字节为X分量，后32个字节为Y分量
	uint8_t  au8Signature[256];			//Firmail服务器私钥对以上字段的签名，目前版本使用SM3withSM2签名
} KeychainCreateReq;

//KeyChain创建码
typedef struct tagKeychainCreateCode
{
	uint32_t u32Magic;					// 魔数，值为0x6b636363，后续数据结构与此相同
	uint32_t u32Version;				// 版本号，值为0x10000，后续数据结构与此相同
	uint32_t u32Flags;
	uint32_t u32TimeStamp;				//时间戳，单位秒
	uint8_t  au8ID[16];					//KeyChain的ID
	uint8_t au8KeyBagID[8];				//KeyBagID
	uint8_t  au8AccessCodePubKey[64];   //SM2公钥，前32个字节为X分量，后32个字节为Y分量
	uint8_t  au8Signature[256];			//加密机服务器私钥对以上字段的签名，目前版本使用SM3withSM2签名
} KeychainCreateCode;

//绑定验证码
typedef struct tagKeybagBindCode
{
	uint32_t u32Magic;
	uint32_t u32Version;
	uint32_t u32Flags;
	uint32_t u32TimeStamp;
	uint8_t  au8KeyBagID[8];
	uint8_t  au8PhoneNumber[16];		//手机号码，如不足16字节，后面以0填充
	uint8_t  au8BindCode[256];			//使用加密机证书加密的BindCode密文（SM2），其明文为16字节的ASCII字符，若不足16字节后面以0填充
	uint8_t  au8Signature[256];			//使用KeyBag设备私钥对以上字段的签名（SM3withSM2）
} KeybagBindCode;

//绑定验证码校验包
typedef struct tagKeybagBindCodeVerify
{
	uint32_t u32Magic;
	uint32_t u32Version;
	uint32_t u32Flags;
	uint32_t u32TimeStamp;
	uint8_t  au8KeyBagID[8];
	uint8_t  au8PhoneNumber[16];		//手机号码，如不足16字节，后面以0填充
	uint8_t  au8BindCode[16];			//BindCode明文，为16字节的ASCII字符，若不足16字节用0补齐
	uint8_t  au8Mac[32];				//使用Kmac密钥对以上字段进行HMAC-SM3运算得到的MAC值
} KeybagBindCodeVerify;

//创建Circle请求包
typedef struct tagKeybagCreateCircleReq
{
	uint32_t u32Magic;
	uint32_t u32Version;
	uint32_t u32Flags;
	uint32_t u32TimeStamp;
	uint8_t  au8KeyBagID[8];
	uint8_t  au8PhoneNumber[16];		//手机号码，如不足16字节，后面以0填充
	uint8_t  au8BindCode[256];			//使用加密机证书加密的BindCode密文（SM2），其明文为16字节的ASCII字符，若不足16字节后面以0填充
	uint8_t  au8SyncPubKey[64];			//同步公钥（SM2），前32个字节为X分量，后32个字节为Y分量
	uint8_t  au8Signature[64];			//同步私钥对以上字段的签名（SM3withSM2），使用同步公钥验签（即au8SyncPubKey字段）
} KeybagCreateCircleReq;

//Circle数据结构-CirclePubkey
typedef struct tagKeybagCirclePubkey
{
	uint8_t  u8KeyBagSeq;				//加入到Circle中的KeyBag序号，从1开始逐一递增
	uint8_t  au8Reserved[7];			//用于数据结构按8字节对齐
	uint8_t  au8KeyBagID[8];			//KeyBagID
	uint8_t  au8SyncPubKey[64];			//KeyBag的同步公钥
} KeybagCirclePubkey;

//Circle数据结构-Circle
typedef struct tagKeybagCircle
{
	uint32_t u32Magic;
	uint32_t u32Version;
	uint32_t u32Flags;
	uint32_t u32TimeStamp;
	uint8_t  au8PhoneNumber[16];		//手机号码，如不足16字节，后面以0填充
	uint8_t  au8Uuid[16];				//CircleID，绑定第一个keyBag时由加密机内部生成的一个UUID，如果是添加第二个第三个...时，则来自老Circle包中
	uint32_t u32Count;					//KeyBag同步公钥数组中元素个数
	KeybagCirclePubkey *kcPubKey;		//KeyBag同步公钥数组，一个Circle里可以有多个KeyBag
	uint8_t  au8Signature[256];			//加密机服务器私钥对以上字段的签名，目前版本使用SM3withSM2签名
} KeybagCircle;

//加入Circle审批包
typedef struct tagKeybagJoinCircleApprove
{
	uint32_t u32Magic;
	uint32_t u32Version;
	uint32_t u32Flags;
	uint32_t u32TimeStamp;
	uint8_t  au8KeyBagID[8];
	uint8_t  au8PhoneNumber[16];
	uint8_t  au8Uuid[16];				//老Circle的UUID
	uint8_t  au8BindCode[256];			//使用加密机证书加密的BindCode密文（RSA2048），其明文为16字节的ASCII字符，若不足16字节后面以0填充
	uint8_t  au8SyncPubKey[64];			//新添加进来的KeyBag的同步公钥（SM2）
	uint8_t  au8KeyBagIDApporver[8];	//审批的KeyBag的ID，需要通过该ID去老的Circle包中找到公钥来验签
	uint8_t  au8Signature[64];			//使用审批的KeyBag的同步私钥的签名
} KeybagJoinCircleApprove;


#ifdef __cplusplus
extern "C"{
#endif
		
/************************************************
*函数：SENC_NewDevList()
*功能：初始化加密卡设备列表|| Initialize senc cards list
*参数：
SENCryptCardList		IN		*SencDevsList	//设备列表指针
*返回值：错误码，0为成功
*日期： 2017/03/17 by Wangjf
*备注：
************************************************/
unsigned int SENC_NewDevList(SENCryptCardList IN *SencDevsList);

/************************************************
*函数：SENC_FreeDevList()
*功能：释放加密卡设备列表|| Release senc cards list
*参数：
SENCryptCardList		IN		*SencDevsList	//设备列表指针
*返回值：错误码，0为成功
*日期： 2017/03/17 by Wangjf
*备注：
************************************************/
unsigned int SENC_FreeDevList(SENCryptCardList IN *SencDevsList);

/************************************************
*函数：SENC_GetDevList()
*功能：获取设备列表||Get Sense encrypt card devices list
*参数：
SENCryptCardList*	 OUT	 SencDevsList		//设备列表指针
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
************************************************/
unsigned int SENC_GetDevList(SENCryptCardList* OUT SencDevsList);

/************************************************
*函数：SENC_Open()
*功能：开启目标加密板卡，并返回设备指针||Open Sense encrypt card and create device handle
*参数：
CardInfo*		IN		SencDev			//加密板卡路径信息
SENCHANDLE*		OUT		SencDevHandle	//返回的设备指针
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
************************************************/
unsigned int SENC_Open(CardInfo*	IN		SencDev,
					   SENCHANDLE*	OUT		SencDevHandle);

/************************************************
*函数：SENC_Close()
*功能：关闭目标加密板卡||Close Sense encrypt card 
*参数：
SENCHANDLE		IN		SencDevHandle	//待关闭设备指针
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
************************************************/
unsigned int SENC_Close(SENCHANDLE IN SencDevHandle);

/************************************************
*函数：SENC_Free()
*功能：释放加密板卡句柄空间||Free Sense encrypt card handle 
*参数：
SENCHANDLE		IN		SencDevHandle	//待释放设备指针
*返回值：错误码，0为成功
*日期： 2016/12/26 by Wangjf
*备注：
************************************************/
unsigned int SENC_Free(SENCHANDLE* IN SencDevHandle);

/************************************************
*函数：SENC_ResetByHandle()
*功能：通过加密板卡句柄复位对应加密板卡设备||Reset Senc Card by Senc Handle
*参数：
SENCHANDLE		IN		SencDevHandle	//待复位设备指针
*返回值：错误码，0为成功
*日期： 2017/04/07 by Wangjf
*备注：加密板卡复位后原句柄因过期会被销毁释放
************************************************/
unsigned int SENC_ResetByHandle(SENCHANDLE* IN SencDevHandle);

/************************************************
*函数：SENC_ResetByPort()
*功能：通过加密板卡端口号复位对应加密板卡设备||Reset Senc Card by Serial port 
*参数：
int		IN		TargetPortNumber	//待复位设备端口号（1-16）
*返回值：错误码，0为成功
*日期： 2017/04/07 by Wangjf
*备注：需选择1-16号端口，端口号可通过CardInfo计算得出。
************************************************/
unsigned int SENC_ResetByPort(int IN TargetPortNumber, int IN CaseIndex);




/************************************************
*函数：SENC_EncryptCard_GetState()
*功能：获取加密板卡状态||Get target senc card state
*参数：
SENCHANDLE		IN		SencDevHandle	//设备指针
unsigned char*	OUT		OutEcState		//返回的设备状态buffer
unsigned int	IN		OutEcStateLen	//返回的设备状态长度
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：返回状态 0x00 生产状态；0x01 出厂状态；0x02 空闲状态；0x03 操作状态；0x04 管理状态
************************************************/
unsigned int SENC_EncryptCard_GetState(SENCHANDLE		IN	SencDevHandle,
									   unsigned char*	OUT OutEcState,
									   unsigned int*	OUT	OutEcStateLen);

/************************************************
*函数：SENC_RSA_PrivkeySignatureExternal()
*功能：RSA外部私钥签名||RSA signature with external RSA private key
*参数：
SENCHANDLE		IN		SencDevHandle		//设备指针
EncryptAttr*	IN		inEncAttr			//加密参数结构体
unsigned char*	IN		IV					//加密私钥初始向量，16字节
unsigned int	IN		IVlen				//加密私钥初始向量长度，固定为16
unsigned char*	IN		MAC					//加密私钥mac，16字节
unsigned int	IN		MACLen				//加密私钥mac长度，固定为16
unsigned char*	IN		RsaPrivKeyData		//经过加密的RSA私钥数据
unsigned int	IN		RsaPrivKeyDataLen	//私钥数据长度，固定为1412
unsigned char*	IN		InData				//待签名数据
unsigned int	IN		inDataLen			//待签名数据长度
unsigned char*	OUT		RetSignedData		//返回的已签名数据
unsigned int*	OUT		retSignedDataLen	//返回的已签名数据长度
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：RSA私钥数据经过AES/SM4加密，长度为1412字节
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
RSA私钥加密模式		RSA_PrikeyEncMode	0x01 AES128 / 0x02 AES256 / 0x03 SM4
私钥加密AES秘钥索引	RSA_PrikeyEncIdx	1-64
签名数据哈希算法	RSA_HashAlgorithm	0x01 SHA1 / 0x02 SHA256
数据PADDING模式		RSA_PaddingMode		0x01 NONE / 0x02 PKCS1 V1.5
************************************************/
unsigned int SENC_RSA_PrivkeySignatureExternal(SENCHANDLE		IN	SencDevHandle,
											   EncryptAttr*	IN	inEncAttr,
											   unsigned char*	IN	IV,
											   unsigned int	IN	IVlen,
											   unsigned char*	IN	MAC,
											   unsigned int	IN	MACLen,
											   unsigned char*	IN	RsaPrivKeyData,
											   unsigned int	IN	RsaPrivKeyDataLen,
											   unsigned char*	IN	inData,
											   unsigned int	IN	inDataLen,
											   unsigned char*	OUT retSignedData,
											   unsigned int*	OUT	retSignedDataLen);

/************************************************
*函数：SENC_RSA_PrivkeySignatureInternal()
*功能：RSA内部私钥签名||RSA signature with internal private key
*参数：
SENCHANDLE		IN		SencDevHandle	//设备指针
EncryptAttr*	IN		inEncAttr		//加密参数结构体
unsigned char*	IN		InData			//待签名数据
unsigned int	IN		InDataLen		//待签名数据长度，固定为256
unsigned char*	OUT		RetSignedData	//返回的已签名数据
unsigned int*	OUT		RetSignedDataLen//返回的已签名数据长度

*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
RSA秘钥索引			RSA_InternalKeyIdx	1-128
签名数据哈希算法	RSA_HashAlgorithm	0x01 SHA1 / 0x02 SHA256
数据PADDING模式		RSA_PaddingMode		0x01 NONE / 0x02 PKCS1 V1.5
************************************************/
unsigned int SENC_RSA_PrivkeySignatureInternal(SENCHANDLE		IN	SencDevHandle,
											   EncryptAttr*	IN	inEncAttr,
											   unsigned char*	IN	InData,
											   unsigned int	IN	InDataLen,
											   unsigned char*	OUT RetSignedData,
											   unsigned int*	OUT	RetSignedDataLen);

/************************************************
*函数：SENC_RSA_PrivkeyDecryptExternal()
*功能：RSA外部私钥解密|| RSA decryption with external private key
*参数：
SENCHANDLE			SencDevHandle				//加密卡设备handle
EncryptAttr*		inEncAttr					//传入秘钥参数
unsigned char*		IV							//加密私钥初始向量，16字节
unsigned int		IVlen						//加密私钥初始向量长度，固定为16
unsigned char*		MAC							//加密私钥mac，16字节
unsigned int		MAClen						//加密私钥mac长度，固定为16
unsigned char*		RsaPrivKeyData				//经过加密的RSA私钥数据
unsigned int		RsaPrivKeyDataLen			//私钥数据长度，固定为1412
unsigned char*		inData						//待解密数据
unsigned int		inDataLen					//待解密数据长度，固定为256
unsigned char*		retDecData					//返回已解密数据
unsigned int*		retDecDataLen				//返回已解密数据长度

*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
RSA私钥加密模式		RSA_PrikeyEncMode	0x01 AES128 / 0x02 AES256 / 0x03 SM4
私钥加密AES秘钥索引	RSA_PrikeyEncIdx	1-64
数据PADDING模式		RSA_PaddingMode		0x01 NONE / 0x02 PKCS1 V1.5
************************************************/
unsigned int SENC_RSA_PrivkeyDecryptExternal(SENCHANDLE		IN	SencDevHandle,
											 EncryptAttr*		IN	inEncAttr,
											 unsigned char*	IN	IV,
											 unsigned int		IN	IVlen,
											 unsigned char*	IN	MAC,
											 unsigned int		IN	MAClen,
											 unsigned char*	IN	RsaPrivKeyData,
											 unsigned int		IN	RsaPrivKeyDataLen,
											 unsigned char*	IN	inData,
											 unsigned int		IN	inDataLen,
											 unsigned char*	OUT retDecData,
											 unsigned int*		OUT	retDecDataLen);

/************************************************
*函数：SENC_RSA_PrivkeyDecryptInternal()
*功能：RSA内部私钥解密|| RSA decryption with internal private key
*参数：
SENCHANDLE		IN		SencDevHandle	//设备指针
EncryptAttr*	IN		inEncAttr		//加密参数结构体
unsigned char*	IN		InData			//待解密数据
unsigned int	IN		InDataLen		//待解密数据长度，固定为256
unsigned char*	OUT		RetDecData		//返回的已解密数据
unsigned int*	OUT		RetDecDataLen	//返回的已解密数据长度
*返回值：错误码，0为成功
*日期： 2017/02/16 by Wangjf
*备注：
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
RSA秘钥索引			RSA_InternalKeyIdx	1-128
数据PADDING模式		RSA_PaddingMode		0x01 NONE / 0x02 PKCS1 V1.5
************************************************/
unsigned int SENC_RSA_PrivkeyDecryptInternal(SENCHANDLE		IN	SencDevHandle,
											 EncryptAttr*		IN	inEncAttr,
											 unsigned char*	IN	InData,
											 unsigned int		IN	InDataLen,
											 unsigned char*	OUT RetDecData,
											 unsigned int*		OUT	RetDecDataLen);

/************************************************
*函数：SENC_RSA_PubkeyVerifyExternal()
*功能：RSA外部公钥验签|| Verify signature by external RSA public key
*参数：
SENCHANDLE*			SencDevHandle			//加密卡设备handle
EncryptAttr*		inEncAttr				//传入秘钥参数
unsigned char*		PubKey					//RSA公钥数据
unsigned int		PubKeyLen				//RSA公钥数据长度 512 bytes
unsigned char*		inData					//源数据
unsigned int		inDataLen				//源数据长度
unsigned char*		SignedData				//签名数据
unsigned int		SignedDataLen			//签名数据长度
*日期：2017/05/05 by Wangjf
*备注：
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
签名数据哈希算法	RSA_HashAlgorithm	0x01 SHA1 / 0x02 SHA256
数据PADDING模式		RSA_PaddingMode		0x01 NONE / 0x02 PKCS1 V1.5
************************************************/
unsigned int SENC_RSA_PubkeyVerifyExternal(SENCHANDLE		IN SencDevHandle,
										   EncryptAttr*		IN inEncAttr,
										   unsigned char*	IN PubKey,
										   unsigned int		IN PubKeyLen,
										   unsigned char*	IN inData,
										   unsigned int		IN inDataLen,
										   unsigned char*	IN SignedData,
										   unsigned int		IN SignedDataLen);

/************************************************
*函数：SENC_RSA_PubkeyEncryptExternal()
*功能：RSA外部公钥加密|| Encrypt data by external RSA public key
*参数：
SENCHANDLE*			SencDevHandle			//加密卡设备handle
EncryptAttr*		inEncAttr				//传入秘钥参数
unsigned char*		pubkey					//RSA公钥数据
unsigned int		pubkeyLen				//RSA公钥数据长度 512 bytes
unsigned char*		inData					//待加密数据
unsigned int		inDataLen				//待加密数据长度 不大于256 bytes
unsigned char*		retEncData				//签名返回数据
unsigned int*		retEncDataLen			//签名返回数据长度
*日期：2017/05/05 by Wangjf
*备注：
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
数据PADDING模式		RSA_PaddingMode		0x01 NONE / 0x02 PKCS1 V1.5
************************************************/
unsigned int SENC_RSA_PubkeyEncryptExternal(SENCHANDLE		IN	SencDevHandle,
											EncryptAttr*	IN	inEncAttr,
											unsigned char*	IN	pubkey,
											unsigned int	IN	pubkeyLen,
											unsigned char*	IN	inData,
											unsigned int	IN	inDataLen,
											unsigned char*	OUT retEncData,
											unsigned int*	OUT retEncDataLen);

/************************************************
*函数：SENC_RSA_PubkeyVerifyInternal()
*功能：RSA内部公钥验签|| Verify signature by internal RSA public key
*参数：
SENCHANDLE*			SencDevHandle				//加密卡设备handle
EncryptAttr*		inEncAttr					//传入秘钥参数
unsigned char*		InData						//源数据
unsigned int		InDataLen					//源数据长度
unsigned char*		SignedData					//签名数据
unsigned int		SignedDataLen				//签名数据长度
*日期：2017/05/05 by Wangjf
*备注：
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
签名数据哈希算法	RSA_HashAlgorithm	0x01 SHA1 / 0x02 SHA256
数据PADDING模式		RSA_PaddingMode		0x01 NONE / 0x02 PKCS1 V1.5
************************************************/
unsigned int SENC_RSA_PubkeyVerifyInternal(SENCHANDLE		IN	SencDevHandle,
										   EncryptAttr*		IN	inEncAttr,
										   unsigned char*	IN	InData,
										   unsigned int		IN	InDataLen,
										   unsigned char*	IN	SignedData,
										   unsigned int		IN	SignedDataLen);

/************************************************
*函数：SENC_RSA_PubkeyEncryptInternal()
*功能：RSA内部公钥加密|| Encrypt data by internal RSA public key
*参数：
SENCHANDLE*			SencDevHandle				//加密卡设备handle
EncryptAttr*		inEncAttr					//传入秘钥参数
unsigned char*		InData						//待加密数据
unsigned int		InDataLen					//待加密数据长度 不大于256 bytes
unsigned char*		RetEncData					//签名返回数据
unsigned int*		RetEncDataLen				//签名返回数据长度
*日期：2017/05/05 by Wangjf
*备注：
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
RSA秘钥索引			RSA_InternalKeyIdx	1-128
数据PADDING模式		RSA_PaddingMode		0x01 NONE / 0x02 PKCS1 V1.5
************************************************/
unsigned int SENC_RSA_PubkeyEncryptInternal(SENCHANDLE		IN		SencDevHandle,
											EncryptAttr*	IN		inEncAttr, 
											unsigned char*	IN		InData, 
											unsigned int	IN		InDataLen,
											unsigned char*	OUT		RetEncData, 
											unsigned int*	OUT		RetEncDataLen);

/************************************************
*函数：SENC_AES_Encrypt()
*功能：AES加密||AES encrypt
*参数：
SENCHANDLE		IN		SencDevHandle	//设备指针
EncryptAttr*	IN		inEncAttr		//加密参数结构体
unsigned char*	IN		inCBCiv			//cbc模式下的初始化向量16字节,ECB模式下可以为NULL
unsigned int	IN		inCBCivLen		//cbc模式下的初始化向量长度固定为16,ECB模式下为0
unsigned char*	IN		inData			//待加密数据
unsigned int	IN		inDataLen		//待加密数据长度不能超过2027字节
unsigned char*	OUT		retEncData		//返回的加密数据
unsigned int*	OUT		retEncDataLen	//返回加密数据的长度
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
加密参数结构体需要填充：
AES加密算法位数128/256		AES_EncLength	0x01 AES128 / 0x02 AES256
AES加密模式ECB/CBC			AES_EncMode		0x01 ECB / 0x02 CBC
AES秘钥索引					AES_EncIdx		65-128
************************************************/
unsigned int SENC_AES_Encrypt(SENCHANDLE		IN	SencDevHandle, 
							  EncryptAttr*		IN	inEncAttr,
							  unsigned char*	IN	inCBCiv,
							  unsigned int		IN	inCBCivLen,
							  unsigned char*	IN	inData,
							  unsigned int		IN	inDataLen,
							  unsigned char*	OUT retEncData,
							  unsigned int*		OUT	retEncDataLen);

/************************************************
*函数：SENC_AES_Decrypt()
*功能：AES解密||AES decrypt
*参数：
SENCHANDLE		IN		SencDevHandle	//设备指针
EncryptAttr*	IN		inEncAttr		//加密参数结构体
unsigned char*	IN		inCBCiv			//cbc模式下的初始化向量16字节,ECB模式下可以为NULL
unsigned int	IN		inCBCivLen		//cbc模式下的初始化向量长度固定为16,ECB模式下为0
unsigned char*	IN		inData			//待解密数据
unsigned int	IN		inDataLen		//待解密数据长度不能超过2027字节
unsigned char*	OUT		retDecData		//返回的解密数据
unsigned int*	OUT		retDecDataLen	//返回解密数据的长度
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
加密参数结构体需要填充：
AES加密算法位数128/256		AES_EncLength	0x01 AES128 / 0x02 AES256
AES加密模式ECB/CBC			AES_EncMode		0x01 ECB / 0x02 CBC
AES秘钥索引					AES_EncIdx		65-128
************************************************/
unsigned int SENC_AES_Decrypt(SENCHANDLE		IN		SencDevHandle,
							  EncryptAttr*		IN		inEncAttr,
							  unsigned char*	IN		inCBCiv,
							  unsigned int		IN		inCBCivLen,
							  unsigned char*	IN		inData,
							  unsigned int		IN		inDataLen,
							  unsigned char*	OUT		retDecData,
							  unsigned int*		OUT		retDecDataLen);

/************************************************
*函数：SENC_KEY_RSAKeyGenerate()
*功能：RSA秘钥生成并返回||Generate RSA key and return
*参数：
SENCHANDLE		IN		SencDevHandle	//设备指针
EncryptAttr*	IN		inEncAttr		//加密参数结构体
unsigned char*	IN		IV				//私钥加密初始向量，16字节，可为空，空则默认全0
unsigned int	IN		IVlen			//私钥加密初始向量长度，16或0
unsigned char*	OUT		RetMac			//返回的加密私钥mac，16字节
unsigned int	OUT		RetMacLen		//加密私钥mac长度，固定为16
unsigned char*	OUT		RetRSAPrivKey	//返回的已加密RSA秘钥私钥数据，1412字节
unsigned int	OUT		RetRSAPrivKeyLen//私钥数据长度，固定为1412
unsigned char*	OUT		RetRSAPubKey	//返回的RSA公钥数据，N,E ,512字节
unsigned int	OUT		RetRSAPubKeyLen	//返回的RSA公钥数据长度，固定为512
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
RSA私钥加密模式		RSA_PrikeyEncMode	0x01 AES128 / 0x02 AES256 / 0x03 SM4
私钥加密AES秘钥索引	RSA_PrikeyEncIdx	1-64
************************************************/
unsigned int SENC_KEY_RSAKeyGenerate(SENCHANDLE		IN		SencDevHandle,
									 EncryptAttr*	IN		inEncAttr,
									 unsigned char*	IN		IV,
									 unsigned int	IN		IVlen,
									 unsigned char* OUT		RetMac,
									 unsigned int*	OUT		RetMacLen,
									 unsigned char*	OUT		RetRSAPrivKey,
									 unsigned int*	OUT		RetRSAPrivKeyLen,
									 unsigned char*	OUT		RetRSAPubKey,
									 unsigned int*	OUT		RetRSAPubKeyLen);

/************************************************
*函数：SENC_KEY_RSAKeyGetPublicKey()
*功能：获取内部RSA秘钥公钥||Get internal RSA public key
*参数：
SENCHANDLE		IN		SencDevHandle	//设备指针
EncryptAttr*	IN		inEncAttr		//加密参数结构体
unsigned char*	OUT		RetRsaPubKey	//返回的公钥数据 N,E, 512字节
unsigned int	OUT		RetRsaPubKeyLen	//返回的公钥数据长度
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
加密参数结构体需要填充：
RSA加密模式			RSA_Mode			0x01 RSA2048
RSA秘钥索引			RSA_InternalKeyIdx	1-128
************************************************/
unsigned int SENC_KEY_RSAKeyGetPublicKey(SENCHANDLE		IN		SencDevHandle,
										 EncryptAttr*	IN		inEncAttr,
										 unsigned char*	OUT		RetRsaPubKey,
										 unsigned int*	OUT		RetRsaPubKeyLen);

/************************************************
*函数：SENC_DongleVerify()
*功能：锁验证||Verify key dongle
*参数：
SENCHANDLE		IN		SencDevHandle	//设备指针
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：每次只能插一把锁
************************************************/
unsigned int SENC_DongleVerify(SENCHANDLE IN SencDevHandle);

/************************************************
*函数：SENC_QuitOperateState()
*功能：退出操作状态||Quiting from operation state
*参数：
SENCHANDLE		IN		SencDevHandle	//设备指针
*返回值：错误码，0为成功
*日期： 2016/11/24 by Wangjf
*备注：
************************************************/
unsigned int SENC_QuitOperateState(SENCHANDLE IN SencDevHandle);


//
/************************************************
*函数：SENC_SetLogDirectory(char *log_path);
*功能：设置日志输出路径
*参数：
char *		IN		log_path	//日志输出路径
*返回值：错误码，0为成功
*日期： 2018/11/15 by liuwc
*备注：
************************************************/
void SENC_SetLogDirectory(char *log_path);

/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
#if defined(ALL_)

/************************************************
*函数：SENC_KeyExchange()
*功能：秘钥交换|| Key exchange
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：命令加密卡进行一次秘钥交换更新秘钥。实际使用中，每一个
加密帧发送前都会进行一次秘钥交换，所以开发使用时并不需要刻意调
用该函数
************************************************/
unsigned int SENC_KeyExchange(SENCHANDLE IN SencDevHandle);

/************************************************
*函数：SENC_EncryptCard_GetID()
*功能：获取加密卡ID|| Get senc card's ID
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	OUT		OutEncryptCardID	//加密卡ID, 8字节
unsigned int*	OUT		OutEncryptCardIDLen	//返回的加密卡ID数据长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_EncryptCard_GetID(SENCHANDLE		IN	SencDevHandle,
									unsigned char*	OUT OutEncryptCardID,
									unsigned int*	OUT	OutEncryptCardIDLen);

/************************************************
*函数：SENC_EncryptCard_GetVersion()
*功能：获取加密卡版本信息|| Get senc card's version info
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	OUT		OutEcHwVersion		//加密卡硬件版本信息, 8字节
unsigned int*	OUT		OutEcHwVersionLen	//返回的加密卡硬件版本信息数据长度
unsigned char*	OUT		OutEcFwVersion		//加密卡固件版本信息, 8字节
unsigned int*	OUT		OutEcFwVersionLen	//返回的加密卡固件版本信息数据长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_EncryptCard_GetVersion(SENCHANDLE		IN	SencDevHandle,
										 unsigned char* OUT OutEcHwVersion,
										 unsigned int*	OUT	OutEcHwVersionLen,
										 unsigned char* OUT OutEcFwVersion,
										 unsigned int*	OUT	OutEcFwVersionLen);

/************************************************
*函数：SENC_Product_SetID()
*功能：生产#设置加密卡ID|| Product # Set card's ID
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char*	IN		InEcId			//加密卡ID, 8字节
unsigned int	IN		InEcIdLen		//加密卡ID数据长度，固定为8
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_Product_SetID(SENCHANDLE		IN	SencDevHandle,
								unsigned char*	IN	InEcId,
								unsigned int	IN	InEcIdLen);

/************************************************
*函数：SENC_Product_SetVersion()
*功能：生产#设置加密卡版本信息||  Product # Set senc card's version info
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	IN		InHwVersion			//加密卡硬件版本信息, 8字节
unsigned int	IN		InHwVersionLen		//加密卡硬件版本信息数据长度，固定为8
unsigned char*	IN		InFwVersion			//加密卡固件版本信息, 8字节
unsigned int	IN		InFwVersionLen		//加密卡固件版本信息数据长度，固定为8
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_Product_SetVersion(SENCHANDLE		IN	SencDevHandle,
									 unsigned char* IN	InHwVersion,
									 unsigned int	IN	InHwVersionLen,
									 unsigned char* IN	InFwVersion,
									 unsigned int	IN	InFwVersionLen);

/************************************************
*函数：SENC_Product_GenerateFlashKey()
*功能：生产#生成FLASH秘钥||  Product # Generate FLASH key
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_Product_GenerateFlashKey(SENCHANDLE IN SencDevHandle);

/************************************************
*函数：SENC_Product_SetDHAttributes()
*功能：生产#设置加密卡DH参数||  Product # Set senc card's DH attributes
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char*	IN		InP				//DH交换系数P, 4字节
unsigned int	IN		InPLen			//DH交换系数P长度，固定为4
unsigned char*	IN		InG				//DH交换系数G, 1字节
unsigned int	IN		InGLen			//DH交换系数G长度，固定为1
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_Product_SetDHAttributes(SENCHANDLE		IN	SencDevHandle,
										  unsigned char*	IN	InP,
										  unsigned int		IN	InPLen,
										  unsigned char*	IN	InG,
										  unsigned int		IN	InGLen);

/************************************************
*函数：SENC_Product_SM2KeyGenerate()
*功能：生成板卡设备密钥对||  Generate Senc Card RSA Keys
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char	IN		InEncryptLength	//加密长度，固定为1字节
unsigned char	IN		RsaKeyIdx		//加密密钥索引，固定为1字节
*返回值：错误码，0为成功
*日期： 2018/11/1 by Zhang Tao
*备注：
************************************************/
unsigned int SENC_Product_SM2KeyGenerate(SENCHANDLE		IN SencDevHandle,
										 unsigned char	IN InEncryptLength,
										 unsigned char	IN RsaKeyIdx);

/************************************************
*函数：SENC_Product_RequestCSR()
*功能：向设备请求CSR||  Request CSR From Device
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned int*	OUT		CsrLen			//返回CSR长度
unsigned char*	OUT		Csr				//返回CSR数据
*返回值：错误码，0为成功
*日期： 2018/11/1 by Zhang Tao
*备注：
************************************************/
unsigned int SENC_Product_RequestCSR(SENCHANDLE		IN SencDevHandle,
									 unsigned int*	OUT CsrLen,
									 unsigned char* OUT Csr);

/************************************************
*函数：SENC_Product_DownLoadCert()
*功能：下载证书||  Download Certification
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
uint8_t			IN		CertType		//证书类型，固定为1字节
unsigned int	IN		CertLen			//证书长度，固定为2字节
unsigned char*  IN      Cert			//证书内容
*返回值：错误码，0为成功
*日期： 2018/11/1 by Zhang Tao
*备注：
************************************************/
unsigned int SENC_Product_DownLoadCert(SENCHANDLE		IN SencDevHandle,
									   uint8_t			IN CertType,
									   unsigned int		IN CertLen,
									   unsigned char*	IN Cert);

/************************************************
*函数：SENC_Product_SetDefaultState()
*功能：生产#设置加密卡为出厂状态||  Product # Set senc card to default state
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：该函数需在所有生产设置以及生产测试完成后调用，该状态转换成功后不可逆
************************************************/
unsigned int SENC_Product_SetDefaultState(SENCHANDLE IN SencDevHandle);

/************************************************
*函数：SENC_ProTest_RsaSignature()
*功能：生产测试#RSA 加密功能测试||  Product test# RSA encryption test
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	IN		rsaKey				//RSA秘钥对数据, 1412字节
unsigned int	IN		rsaKeyLen			//RSA秘钥对数据长度，固定为1412
unsigned char*	IN		InData				//待加密数据, 256字节
unsigned int	IN		InDataLen			//待加密数据长度，固定为256
unsigned char*	OUT		SignedData			//返回加密后数据, 256字节
unsigned int*	OUT		SignedDataLen		//返回加密后数据长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：仅加密，需要测试端配合加密/解密比对一致性。
************************************************/
unsigned int SENC_ProTest_RsaSignature(SENCHANDLE		IN		SencDevHandle,
									   unsigned char*	IN		rsaKey,
									   unsigned int		IN		rsaKeyLen,
									   unsigned char*	IN		InData,
									   unsigned int		IN		InDataLen,
									   unsigned char*	OUT		SignedData,
									   unsigned int*	OUT		SignedDataLen);

/************************************************
*函数：SENC_ProTest_AesEncrypt()
*功能：生产测试#AES 加密功能测试||  Product test# AES encryption test
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	IN		pwKey				//AES秘钥, 32字节
unsigned int	IN		pwKeyLen			//AES秘钥长度，固定为32
unsigned char*	IN		InData				//待加密数据, 256字节
unsigned int	IN		InDataLen			//待加密数据长度，固定为256
unsigned char*	OUT		RetData				//返回加密后数据, 256字节
unsigned int*	OUT		RetDataLen			//返回加密后数据长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：AES 256 ECB
************************************************/
unsigned int SENC_ProTest_AesEncrypt(SENCHANDLE			IN		SencDevHandle,
									 unsigned char*		IN		pwKey,
									 unsigned int		IN		pwKeyLen,
									 unsigned char*		IN		InData,
									 unsigned int		IN		InDataLen,
									 unsigned char*		OUT		RetData,
									 unsigned int*		OUT		RetDataLen);

/************************************************
*函数：SENC_ProTest_WriteEp()
*功能：生产测试#防拔开启时写入测试||  Product test# Writing test with eject protection
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	IN		inData				//写入数据， 256字节
unsigned int	IN		inDataLen			//写入数据长度，固定为256
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：理论上开启防拔时数据是无法写入的。调用该函数后再进行读操作，在没有数据写入的情况下返回数据全为0xff。
************************************************/
unsigned int SENC_ProTest_WriteEp(SENCHANDLE		IN	SencDevHandle,
								  unsigned char*	IN	inData,
								  unsigned int		IN	inDataLen);

/************************************************
*函数：SENC_ProTest_WriteNp()
*功能：生产测试#防拔关闭时写入测试||  Product test# Writing test without eject protection
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	IN		inData				//写入数据， 256字节
unsigned int	IN		inDataLen			//写入数据长度，固定为256
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：关闭防拔后数据可以写入。调用该函数后再进行读操作，应返回写入的数据。
************************************************/
unsigned int SENC_ProTest_WriteNp(SENCHANDLE		IN		SencDevHandle,
								  unsigned char*	IN		inData,
								  unsigned int		IN		inDataLen);

/************************************************
*函数：SENC_ProTest_Read()
*功能：生产测试#数据读出测试||  Product test# Writing test without eject protection
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	OUT		outData				//读出数据， 256字节
unsigned int*	OUT		outDataLen			//读出数据长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_ProTest_Read(SENCHANDLE		IN		SencDevHandle, 
							   unsigned char*	OUT		outData, 
							   unsigned int*	OUT		outDataLen);

/************************************************
*函数：SENC_ProTest_FlashSweep()
*功能：生产测试#FLASH数据擦除||  Product test# Erase FLASH data
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：正式发版该函数计划禁用
************************************************/
unsigned int SENC_ProTest_FlashSweep(SENCHANDLE IN SencDevHandle);

/************************************************
*函数：SENC_MC_NewMasterCard()
*功能：添加管理卡|| Bind new master card
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	OUT		RetCardId			//管理卡ID， 8字节
unsigned int*	OUT		RetCardIdLen		//管理卡ID长度
unsigned char*	OUT		RetNums				//剩余可添加管理卡数量， 1字节
unsigned int*	OUT		RetNumsLen			//剩余可添加管理卡数量长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_MC_NewMasterCard(SENCHANDLE		IN		SencDevHandle,
								   unsigned char*	OUT		RetCardId,
								   unsigned int*	OUT		RetCardIdLen,
								   unsigned char*	OUT		RetNums,
								   unsigned int	*	OUT		RetNumsLen);

/************************************************
*函数：SENC_MC_VerifyMasterCard()
*功能：认证管理卡|| Verify master card
*参数：
SENCHANDLE		IN		SencDevHandle			//设备handle
unsigned char*	OUT		RetCardId				//管理卡ID， 8字节
unsigned int*	OUT		RetCardIdLen			//管理卡ID长度
unsigned char*	OUT		RetCardPermission		//管理权限， 1字节，未成功时为0，第3张卡通过认证则为1
unsigned int*	OUT		RetCardPermissionLen	//管理权限长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_MC_VerifyMasterCard(SENCHANDLE		IN		SencDevHandle,
									  unsigned char*	OUT		RetCardId,
									  unsigned int*		OUT		RetCardIdLen,
									  unsigned char*	OUT		RetCardPermission,
									  unsigned int*		OUT		RetCardPermissionLen);

/************************************************
*函数：SENC_MC_DeleteMasterCard()
*功能：删除目标管理卡|| Delete master card
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	IN		inCardId			//待删除管理卡ID， 8字节
unsigned int	IN		inCardIdLen			//待删除管理卡ID长度，固定为8
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_MC_DeleteMasterCard(SENCHANDLE		IN	SencDevHandle,
									  unsigned char*	IN	inCardId,
									  unsigned int		IN	inCardIdLen);

/************************************************
*函数：SENC_MC_GetMasterCardId()
*功能：获取已绑定管理卡ID|| Get info of bound master cards
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	OUT		RetCardInfo			//已绑定管理卡信息， 45字节
unsigned int*	OUT		RetCardInfoLen		//已绑定管理卡信息长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：返回信息组成为：[管理卡ID 8字节 + 管理卡标识 1字节] * 5
管理卡标识1为已验证，0为未验证，0xFF为未添加。
未添加管理卡返回对应数据为8字节0
************************************************/
unsigned int SENC_MC_GetMasterCardId(SENCHANDLE			IN		SencDevHandle,
									 unsigned char*		OUT		RetCardInfo,
									 unsigned int*		OUT		RetCardInfoLen);

/************************************************
*函数：SENC_MC_QuitManagement()
*功能：退出管理状态|| Quiting from management state
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_MC_QuitManagement(SENCHANDLE IN SencDevHandle);

/************************************************
*函数：SENC_MC_SetStandby()
*功能：设置为禁止/空闲状态|| Set card to Standby State
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：板卡在出厂状态下，添加全部5张管理卡后调用，并切换为禁止状态。（不可逆）
************************************************/
unsigned int SENC_MC_SetStandby(SENCHANDLE IN SencDevHandle);

/************************************************
*函数：SENC_MC_GetBackupKey()
*功能：获取备份秘钥|| Get backup key
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	OUT		RetCardSign			//管理卡验证标识， 5字节 未验证为0，已验证为1
unsigned int*	OUT		RetCardSignLen		//管理卡验证标识长度
unsigned char*	OUT		RetCardInfo			//返回备份秘钥信息， 208字节
unsigned int*	OUT		RetCardInfoLen		//返回备份秘钥信息长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：在全部5个标识都为1之前，不返回备份秘钥信息208字节。
备份秘钥信息组成：
[随机数 8字节] + [管理卡ID 8字节(有顺序关系)]*5 + [已加密备份秘钥 16字节]*10
************************************************/
unsigned int SENC_MC_GetBackupKey(SENCHANDLE		IN		SencDevHandle,
								  unsigned char*	OUT		RetCardSign,
								  unsigned int*		OUT		RetCardSignLen,
								  unsigned char*	OUT		RetCardInfo,
								  unsigned int*		OUT		RetCardInfoLen);

/************************************************
*函数：SENC_MC_SetRecoveryKey()
*功能：设置备份秘钥|| Set backup key
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	IN		inCardInfo			//备份秘钥信息， 208字节
unsigned int	IN		inCardInfoLen		//备份秘钥信息长度，固定为208
unsigned char*	OUT		RetCardSign			//管理卡验证标识， 6字节
unsigned int*	OUT		RetCardSignLen		//管理卡验证标识长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：管理卡验证标识组成：
[管理卡验证标识 1字节]*5 + [设置标识 1字节]
管理卡验证标识1表示已验证，0为未验证。设置标识1为已设置，0为未设置。
当验证3张管理卡后，即管理卡标识有3个为1时，设置标识返回1，代表恢复秘钥设置成功。
************************************************/
unsigned int SENC_MC_SetRecoveryKey(SENCHANDLE		IN		SencDevHandle,
									unsigned char*	IN		inCardInfo,
									unsigned int	IN		inCardInfoLen,
									unsigned char*	OUT		RetCardSign,
									unsigned int*	OUT		RetCardSignLen);

/************************************************
*函数：SENC_DK_NewDongle()
*功能：绑定加密锁|| Bind Elite4 dongle
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：绑定当前插入的加密锁。同一时间只能插1把锁。
************************************************/
unsigned int SENC_DK_NewDongle(SENCHANDLE IN SencDevHandle);

/************************************************
*函数：SENC_DK_GetDonglesId()
*功能：获取加密锁ID信息|| Get info of bound dongle 
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	OUT		RetDongleIdInfo		//锁ID信息，27字节
unsigned int*	OUT		RetDongleIdInfoLen	//锁ID信息长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：管理卡验证标识组成：
[锁序号 1字节 + 锁ID 8字节]*3
锁序号为0xff则标识锁不存在，后续8字节ID为全为0
************************************************/
unsigned int SENC_DK_GetDonglesId(SENCHANDLE		IN		SencDevHandle,
								  unsigned char*	OUT		RetDongleIdInfo,
								  unsigned int*		OUT		RetDongleIdInfoLen);

/************************************************
*函数：SENC_DK_DeleteDongle()
*功能：删除加密锁|| Delete bound dongle
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char*	IN		DongleID		//锁ID，8字节，可为空
unsigned int	IN		DongleIDLen		//锁ID长度，固定为8或者0（当DongleID为空时）
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：当填写锁ID时，则加密板卡会尝试删除跟ID的已绑加密锁。
若锁ID为空，则加密板卡会尝试删除当前插入主机端的加密锁。
************************************************/
unsigned int SENC_DK_DeleteDongle(SENCHANDLE		IN		SencDevHandle,
								  unsigned char*	IN		DongleID,
								  unsigned int		IN		DongleIDLen);

/************************************************
*函数：SENC_DK_GetVerifyRand()
*功能：获取加密锁验证信息|| Get info of dongle verification
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char*	OUT		retRndNum		//返回验证随机数，8字节
unsigned int	IN		retRndNumLen	//返回验证随机数长度，固定为8
unsigned char*	OUT		FlashKey		//返回加密FLASH秘钥，8字节
unsigned int	IN		FlashKeyLen		//返回加密FLASH秘钥长度，固定为8
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：从加密板卡获取加密锁认证所需信息。
因存在加密锁操作的中间过程不常用，
顶层加密锁认证直接调用封装好的SENC_DongleVerify
************************************************/
unsigned int SENC_DK_GetVerifyRand(SENCHANDLE		IN	SencDevHandle,
								   unsigned char*	OUT InAuthKeyIdx,
								   unsigned int *	OUT InAuthKeyIdxLen,
								   unsigned char*	OUT FlashDecKeyIdx,
								   unsigned int *	OUT FlashDecKeyIdxLen,
								   unsigned char*	OUT retRndNum,
								   unsigned int*	OUT	retRndNumLen,
								   unsigned char*	OUT FlashKey,
								   unsigned int*	OUT	FlashKeyLen);

/************************************************
*函数：SENC_DK_VerifyDongle()
*功能：验证加密锁|| Verify dongle
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char*	IN		inRndNum		//验证随机数，8字节
unsigned int	IN		inRndNumLen		//验证随机数长度，固定为8
unsigned char*	IN		FlashKey		//解密后FLASH秘钥，8字节
unsigned int	IN		FlashKeyLen		//解密后FLASH秘钥长度，固定为8
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：将处理后的加密锁认证信息发送给加密板卡。
因存在加密锁操作的中间过程不常用，
顶层加密锁认证直接调用封装好的SENC_DongleVerify
************************************************/
unsigned int SENC_DK_VerifyDongle(SENCHANDLE		IN	SencDevHandle,
								  unsigned char		IN	InAuthKeyIdx,
								  unsigned char		IN	FlashDecKeyIdx,
								  unsigned char*	IN	inRndNum,
								  unsigned int		IN	inRndNumLen,
								  unsigned char*	IN	FlashKey,
								  unsigned int		IN	FlashKeyLen);

/************************************************
*函数：SENC_KEY_RSAKeyGenerateInternal()
*功能：卡内生成RSA秘钥对并存储于卡内|| Generate RSA key and stored in Senc card
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char	IN		InEncryptBits	//RSA秘钥长度，固定为1，代表2048位
unsigned char	IN		RsaKeyIdx		//RSA秘钥索引号，1-128
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_KEY_RSAKeyGenerateInternal(SENCHANDLE		IN	SencDevHandle,
											 unsigned char	IN	InEncryptBits,
											 unsigned char	IN	RsaKeyIdx);

/************************************************
*函数：SENC_KEY_SymmetricKeyGenerate()
*功能：生成对称秘钥对并存储于卡内|| Generate symmetric keys and stored in Senc card
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char	IN		InEncryptType	//对称类型秘钥类型，1代表AES128||2代表AES256||3代表SM4
unsigned char	IN		inKeyIdx		//秘钥索引号，AES128/256 为1-128，SM4为1-64
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_KEY_SymmetricKeyGenerate(SENCHANDLE		IN	SencDevHandle,
										   unsigned char	IN	InEncryptType,
										   unsigned char	IN	inKeyIdx);

/************************************************
*函数：SENC_KEY_ImportKey()
*功能：导入秘钥|| Import key into senc card
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char	IN		InEncryptType	//对称类型秘钥类型，1代表AES128||2代表AES256||3代表SM4
unsigned char	IN		inKeyIdx		//秘钥索引号，AES128/256 为1-128，SM4为1-64
unsigned char*	IN		inKeyData		//秘钥数据，AES128/SM4为16字节，AES256为32字节
unsigned int	IN		inKeyDataLen	//秘钥数据长度，AES128/SM4为16，AES256为32
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：暂不支持RSA秘钥导入
************************************************/
unsigned int SENC_KEY_ImportKey(SENCHANDLE		IN	SencDevHandle,
								unsigned char	IN	InEncryptType,
								unsigned char	IN	inKeyIdx,
								unsigned char*	IN	inKeyData,
								unsigned int	IN	inKeyDataLen);

/************************************************
*函数：SENC_KEY_DeleteKey()
*功能：删除秘钥|| Delete keys
*参数：
SENCHANDLE		IN		SencDevHandle	//设备handle
unsigned char	IN		InEncryptType	//待删除秘钥类型，1代表AES128||2代表AES256||3代表SM4||4代表RSA2048
unsigned char	IN		DelKeyId		//待删除秘钥索引号，AES128/256/RSA2048 为1-128，SM4为1-64
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：
************************************************/
unsigned int SENC_KEY_DeleteKey(SENCHANDLE		IN	SencDevHandle,
								unsigned char	IN	InEncryptType,
								unsigned char	IN	DelKeyId);

/************************************************
*函数：SENC_KEY_QueryKey()
*功能：秘钥查询|| Query keys
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char*	OUT		RetAes128state		//AES128 秘钥状态，16字节
unsigned int*	OUT		RetAes128stateLen	//AES128 秘钥状态长度
unsigned char*	OUT		RetAes256state		//AES256 秘钥状态，16字节
unsigned int*	OUT		RetAes256stateLen	//AES256 秘钥状态长度
unsigned char*	OUT		RetSm4state			//SM4 秘钥状态，8字节
unsigned int*	OUT		RetSm4stateLen		//SM4 秘钥状态长度
unsigned char*	OUT		RetRsa2048state		//RSA2048 秘钥状态，16字节
unsigned int*	OUT		RetRsa2048stateLen	//RSA2048 秘钥状态长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：16字节共128位，每一位对应一个秘钥状态，1为存在，0为未生成。
以第一字节为例，从右到左（从低位到高位）对应秘钥索引1-8
************************************************/
unsigned int SENC_KEY_QueryKey(SENCHANDLE		IN		SencDevHandle,
							   unsigned char*	OUT		RetAes128state,
							   unsigned int*	OUT		RetAes128stateLen,
							   unsigned char*	OUT		RetAes256state,
							   unsigned int*	OUT		RetAes256stateLen,
							   unsigned char*	OUT		RetSm4state,
							   unsigned int*	OUT		RetSm4stateLen,
							   unsigned char*	OUT		RetRsa2048state,
							   unsigned int*	OUT		RetRsa2048stateLen);

/************************************************
*函数：SENC_KEY_BackupKey()
*功能：获取秘钥备份数据|| Get key backup data
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char	IN		InEncryptType		//秘钥类型，1代表AES128||2代表AES256||3代表SM4||4代表RSA2048
unsigned char	IN		BackupKeyId			//待备份秘钥索引号，AES128/256/RSA2048 为1-128，SM4为1-64
unsigned char*	OUT		RetBakData			//返回秘钥备份数据
unsigned int*	OUT		RetBakDataLength	//返回秘钥备份数据长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：一般与SENC_MC_GetBackupKey组合使用
************************************************/
unsigned int SENC_KEY_BackupKey(SENCHANDLE		IN	SencDevHandle,
								unsigned char	IN	InEncryptType,
								unsigned char	IN	BackupKeyId,
								unsigned char*	OUT RetBakData,
								unsigned int*	OUT RetBakDataLength);

/************************************************
*函数：SENC_KEY_RecoverKey()
*功能：恢复秘钥备份数据|| recover key from backup data
*参数：
SENCHANDLE		IN		SencDevHandle		//设备handle
unsigned char	IN		InEncryptType		//秘钥类型，1代表AES128||2代表AES256||3代表SM4||4代表RSA2048
unsigned char	IN		KeyId				//待备份秘钥索引号，AES128/256/RSA2048 为1-128，SM4为1-64
unsigned char*	OUT		inBakData			//输入秘钥备份数据
unsigned int*	OUT		KeyDataLength		//输入秘钥备份数据长度
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：一般与SENC_MC_SetRecoveryKey组合使用
************************************************/
unsigned int SENC_KEY_RecoverKey(SENCHANDLE		IN	SencDevHandle,
								 unsigned char	IN	InEncryptType,
								 unsigned char	IN	KeyId,
								 unsigned char* IN	inBakData,
								 unsigned int	IN	KeyDataLength);

/************************************************
*函数：SENC_DK_NewDongleGroup()
*功能：加密板卡群绑定加密锁 || Group bind new elite4 dongle to senc cards in the list
*参数：
SENCryptCardList*		IN		DevList		//设备列表指针
*返回值：错误码，0为成功
*日期： 2017/04/10 by Wangjf
*备注：将当前插入的加密锁与所有列表中的设备绑定。
************************************************/
unsigned int SENC_DK_NewDongleGroup(SENCryptCardList* IN DevList);

#endif

#if defined __ALTER_ON__


unsigned int SENC_Alternative_Hash(SENCHANDLE IN SencDevHandle,
								   unsigned char hashAlgo,
								   const unsigned char* inData,
								   unsigned int inDataLen,
								   unsigned char* retData,
								   unsigned int* retDataLen);

unsigned int SENC_Alternative_GenerateKeyPair(SENCHANDLE IN SencDevHandle,
											  unsigned char keyBits,
											  unsigned char EncMethod,
											  unsigned char EncIdx,
											  unsigned char* IN IV,
											  unsigned int IN IVlen,
											  unsigned char* OUT RetMAC,
											  unsigned int*	OUT	RetMACLen,
											  unsigned char* OUT RetRSAPrivKey,
											  unsigned int* OUT RetRSAPrivKeyLen,
											  unsigned char* OUT RetRSAPubKey,
											  unsigned int* OUT RetRSAPubKeyLen);

unsigned int SENC_Alternative_SignatureExternal(SENCHANDLE IN SencDevHandle,
												unsigned char keyBits,
												unsigned char EncMethod,
												unsigned char EncIdx,
												unsigned char* IN IV,
												unsigned int IN IVlen,
												unsigned char* IN MAC,
												unsigned int	IN	MACLen,
												unsigned char* IN RSAPrivKey,
												unsigned int IN RSAPrivKeyLen,
												unsigned char* IN inData,
												unsigned int IN inDataLen,
												unsigned char* OUT retSignedData,
												unsigned int* OUT retSignedDataLen);

unsigned int SENC_Alternative_VerifyExternal(SENCHANDLE IN SencDevHandle,
											 unsigned char keyBits,
											 unsigned char* IN RSAPubKey,
											 unsigned int IN RSAPubKeyLen,
											 unsigned char* IN SignedData,
											 unsigned int IN SignedDataLen,
											 unsigned char* OUT retDecrypto,
											 unsigned int* OUT retDecryptoLen);

unsigned int SENC_Alternative_SignatureInternal(SENCHANDLE IN SencDevHandle,
												unsigned char keyBits,
												unsigned char KeyIdx,
												unsigned char* IN inData,
												unsigned int IN inDataLen,
												unsigned char* OUT retSignedData,
												unsigned int* OUT retSignedDataLen);

unsigned int SENC_Alternative_VerifyInternal(SENCHANDLE IN SencDevHandle,
											 unsigned char keyBits,
											 unsigned char KeyIdx,
											 unsigned char* IN SignedData,
											 unsigned int IN SignedDataLen,
											 unsigned char* OUT retDecrypto,
											 unsigned int* OUT retDecryptoLen);

unsigned int SENC_Alternative_PBKDF2Encrypt(SENCHANDLE IN SencDevHandle,
											unsigned char HashMacAlgo,
											unsigned char HashSaltAttr,
											unsigned int iteration,
											unsigned int exportKeyLen,
											unsigned char* IN inPwData,
											unsigned int IN inPwDataLen,
											unsigned char* IN inSaltData,
											unsigned int IN inSaltDataLen,
											unsigned char* OUT exportKeydata);
#endif

#if defined __DATA_PROTECTOR_ON__

//签发用户公钥
unsigned int SENC_DataProtector_SignUserPubKey(SENCHANDLE IN SencDevHandle,
											   UserPubKey* IN  userkey,
											   UserPubKey* OUT userkey_new);
//生成云端秘钥
unsigned int SENC_DataProtector_GenCloudKey(SENCHANDLE IN SencDevHandle,
											KeyRecordRequest* IN req, 
											UserPubKey* IN userPubKey,
											KeyRecord* OUT key);
//设置云端秘钥有效期
unsigned int SENC_DataProtector_SetWebKeyPeriod(SENCHANDLE IN SencDevHandle,
												KeyRecord* IN key, 
												UserPubKey* IN userPubKey,
												KeyPeriod* IN keyPeriod, 
												KeyRecord* OUT key_new);
//生成秘钥种子S1
unsigned int SENC_DataProtector_GenS1(SENCHANDLE IN SencDevHandle,
									  KeyRecord* IN key, 
									  UserPubKey* IN userkey,
									  License* IN license,
									  S1Cipher* OUT S1_E_Kc,
									  S1Cipher* OUT S1_E_Ku,
									  License* OUT license_new);
//签发许可
unsigned int SENC_DataProtector_IssueLicense(SENCHANDLE IN SencDevHandle,
											 KeyRecord* IN key, 
											 UserPubKey* IN userkey,
											 uint8_t* IN LicID,
											 License* IN fatherLic,
											 LicenseRequest* IN LicReq,
											 License* OUT Lic);
//转换密文
unsigned int SENC_DataProtector_CipherConvert(SENCHANDLE IN SencDevHandle,
											  KeyRecord* IN key, 
											  UserPubKey* IN userkey,
											  License* IN Lic,
											  S1Cipher* IN S1_E_Kc,
											  S1Cipher* OUT S1_E_Ku,
											  License* OUT Lic_new);

unsigned int SENC_DataProtector_SetMacCalculateKey(SENCHANDLE IN SencDevHandle,
												   uint8_t* IN UserData, 
												   uint32_t IN UserDataLen);

unsigned int SENC_DataProtector_GetRTCTime(SENCHANDLE IN SencDevHandle,
										   uint64_t* OUT lpRTCtime);

unsigned int SENC_DataProtector_GetSupportedAlgorithm(SENCHANDLE IN SencDevHandle,
													  uint8_t* OUT uiSupportedAlgo);

unsigned int SENC_DataProtector_SetRTCTime(SENCHANDLE IN SencDevHandle,
										   uint8_t* IN Pincode, 
										   uint32_t IN PincodeLen,
										   uint64_t* IN TimeStamp);


//获取板卡初始化状态
unsigned int SENC_DataProtector_GetChipInitStatus(SENCHANDLE IN SencDevHandle,
												  unsigned char* OUT OutEcState,
												  unsigned int* OUT OutEcStateLen);
//从板卡获取初始化请求包
unsigned int SENC_DataProtector_GetInitReq(SENCHANDLE IN SencDevHandle,
										   ChipInitRequest* OUT Req,
										   uint8_t* OUT CaCert,
										   uint32_t* OUT CaCertLen,
										   uint8_t* OUT Cert,
										   uint32_t* OUT CertLen,
										   uint8_t* OUT Pri,
										   uint8_t* OUT Pub);
//板卡执行初始化请求包
unsigned int SENC_DataProtector_ChipInit(SENCHANDLE IN SencDevHandle,
										 ChipInitCommand IN Cmd,
										 uint8_t * IN CaCert,
										 uint32_t IN CaCertLen,
										 uint8_t * IN Cert,
										 uint32_t IN CertLen);
//从板卡获取认证管理员锁数据包
unsigned int SENC_DataProtector_GetAuthPackage(SENCHANDLE IN SencDevHandle,
											   AuthAdminKey* OUT pkg);

//创建KeyChain
unsigned int SENC_KeyManager_CreateKeyChain(SENCHANDLE IN SencDevHandle,
											KeychainCreateReq IN KCCreateReq,
											uint32_t IN KCCreateReqLen,
											uint8_t* IN CaCert,
											uint32_t IN CaCertLen,
											uint8_t* IN FirmailCert,
											uint32_t IN FirmailCertLen,
											uint8_t* IN KeyBagId,
											KeychainCreateCode* OUT KCCreateCode,
											uint32_t* OUT KCCreateCodeLen);

//签发BindCode
unsigned int SENC_KeyManager_BindCode(SENCHANDLE IN SencDevHandle,
									  KeybagBindCode IN KBBindCode,
									  uint32_t IN KBBindCodeLen,
									  uint8_t* IN CaCert,
									  uint32_t IN CaCertLen,
									  uint8_t* IN KeyBagCert,
									  uint32_t IN KeyBagCertLen,
									  uint8_t* OUT BindCodePlain,
									  uint8_t* OUT PhoneNumber,
									  uint8_t* OUT BindCodeCipher,
									  uint32_t* OUT BindCodeCipherLen);

//创建Circle
unsigned int SENC_KeyManager_CreateCircle(SENCHANDLE IN SencDevHandle,
										  uint8_t* IN circle_id,
										  KeybagCreateCircleReq IN KBCreateCircleReq,
										  uint32_t IN KBCreateCircleReqLen,
										  uint8_t* IN BindCodeVrfPkgCipher,
										  uint32_t IN BindCodeVrfPkgCipherLen,
										  uint32_t* OUT TimeStamp,
										  KeybagCircle* OUT KBCircle,
										  uint32_t* OUT KBCircleLen);

//加入Circle
unsigned int SENC_KeyManager_JoinCircle(SENCHANDLE IN SencDevHandle,
										KeybagCircle IN KBOldCircle,
										uint32_t IN KBOldCircleLen,
										KeybagJoinCircleApprove IN KBJoinCircleApprove,
										uint32_t IN KBJoinCircleApproveLen,
										uint8_t* IN BindCodeVrfPkgCipher,
										uint32_t IN BindCodeVrfPkgCipherLen,
										uint32_t* OUT TimeStamp,
										KeybagCircle* OUT KBNewCircle,
										uint32_t* OUT KBNewCircleLen);


#endif

#ifdef __cplusplus
}
#endif // ALL_
#endif // LIBSENC_LIBSENC_H_